<!-- === BEGIN index.html === -->
const dDone        = document.getElementById("dDone");
const dAvg         = document.getElementById("dAvg");
const dPasses      = document.getElementById("dPasses");
const dFails       = document.getElementById("dFails");
const submitLmsBtn = document.getElementById("submitLmsBtn");
const submitHint   = document.getElementById("submitHint");

function hideDashboard(){ dashboard?.classList.add("hidden"); }
function showDashboard(){ document.getElementById("list").classList.add("hidden"); detail.classList.add("hidden"); dashboard.classList.remove("hidden"); navDashboard?.classList.add("active"); navTickets?.classList.remove("active"); renderDashboard(); }
navDashboard?.addEventListener('click', showDashboard);
navTickets?.addEventListener('click', showList);

function allGraded(){ return state.tickets.every(t => t.grade && typeof t.grade.score === "number"); }
function renderDashboard(){
  const done = state.tickets.filter(t => t.grade);
  const passes = done.filter(t => !!t.grade.pass).length;
  const fails  = done.length - passes;
  const avg = done.length ? (done.reduce((a,t)=>a+(t.grade.score||0),0) / done.length) : 0;
  dDone.textContent = `${done.length} / ${state.tickets.length}`;
  dAvg.textContent = done.length ? `${avg.toFixed(0)}/100` : "—";
  dPasses.textContent = passes;
  dFails.textContent = fails;
  dashTable.innerHTML = state.tickets.map(t => `
    <tr>
      <td class=\"small\">${esc(t.subject)}</td>
      <td class=\"small\">${esc(t.status)}</td>
      <td class=\"small\">${esc(t.assignee||"—")}</td>
      <td class=\"small\">${t.grade ? t.grade.score.toFixed(0) : "—"}</td>
      <td class=\"small\">${t.grade ? (t.grade.pass ? "✅" : "❌") : "—"}</td>
    </tr>`).join("");
  const ready = allGraded();
  submitLmsBtn.disabled = !ready;
  submitHint.textContent = ready ? "All tickets graded. You can submit your results to TalentLMS." : "Finish all tickets and grading to enable submission.";
}

submitLmsBtn?.addEventListener('click', async () => {
  const graded = state.tickets.filter(t=>t.grade);
  const averageScore = graded.length ? Math.round(graded.reduce((a,t)=>a+(t.grade.score||0),0)/graded.length) : 0;
  const payload = {
    totalTickets: state.tickets.length,
    graded: graded.length,
    averageScore,
    passCount: graded.filter(t=>t.grade.pass).length,
    tickets: state.tickets.map(t => ({ id: t.id, subject: t.subject, status: t.status, assignee: t.assignee, score: t.grade?.score ?? null, pass: !!t.grade?.pass })),
    // optional: if you set window.SIM_USER_EMAIL in the hosting page, we'll pass it through
    userEmail: window.SIM_USER_EMAIL || undefined
  };
  try{
    const resp = await fetch('/api/lms-submit', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
    if(!resp.ok) throw new Error('Submit failed');
    toast('Results submitted to LMS');
  }catch(e){ console.error(e); alert('Could not submit to LMS. Ask your trainer to check server logs.'); }
});

renderAll();
showList();
})();
</script>

<!-- Client-side grading wrapper -->
<script>
(() => {
  window.gradeAttempt = async function gradeAttempt(ticket, attempt, weights) {
    // Merge weights
    const w = Object.assign(
      {
        sections: 60, status: 25, assignee: 15, keywords: 0, pass: 80,
        sectionWeights: { Greeting: 8, Opener: 8, Solution: 67, Closer: 8, "Sign-Off": 9 }
      },
      weights || {}
    );

    const reply = String(attempt.reply || "");
    const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));
    const eq = (a,b)=>String(a??'').trim().toLowerCase()===String(b??'').trim().toLowerCase();

    const expectedStatus   = ticket.expected?.requiredStatus ?? "";
    const expectedAssignee = ticket.expected?.requiredAssignee ?? "";
    const statusOk   = eq(attempt.status,   expectedStatus);
    const assigneeOk = eq(attempt.assignee, expectedAssignee);

    // ===== Branch 1: Macro-only tickets =====
    if (ticket.expected?.macroOnly) {
      const target = String(ticket.expected?.macroCommand || "").trim();
      const macroOk = target ? reply.trim() === target : reply.trim().startsWith("/");

      // Score macro using the same "sections" bucket so totals stay balanced
      const sum = Math.max(1, (w.sections||0) + (w.status||0) + (w.assignee||0) + (w.keywords||0));
      const sMacro    = (macroOk    ? 100 : 0) * (w.sections || 0) / sum;
      const sStatus   = (statusOk   ? 100 : 0) * (w.status   || 0) / sum;
      const sAssignee = (assigneeOk ? 100 : 0) * (w.assignee || 0) / sum;
      const score = sMacro + sStatus + sAssignee;

      const checks = [
        { label: "Macro command is correct", ok: macroOk, detail: `Typed: ${reply || "—"}` },
        { label: `Submit As is "${expectedStatus}"`, ok: statusOk, detail: `Selected: ${attempt.status ?? "—"}` },
        { label: `Assignee is "${expectedAssignee}"`, ok: assigneeOk, detail: `Selected: ${attempt.assignee ?? "—"}` }
      ];

      return {
        checks,
        score,
        pass: score >= (w.pass || 0),
        structurePct: macroOk ? 100 : 0
      };
    }

    // ===== Branch 2: Normal structured tickets =====
    // 1) Ask API for structure checks, passing the ticket-specific rubric
    let ai = null;
    try {
      const rubric = typeof ticket?.expected?.requirements === "string"
        ? ticket.expected.requirements
        : (ticket?.expected?.requirements?.guidance || "");

      const resp = await fetch("/api/grade", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ reply, rubric })
      });
      if (resp.ok) ai = await resp.json();
    } catch (err) {
      console.warn("AI grading unavailable, using deterministic checks only.", err);
    }

    const structureLabels = ["Greeting", "Opener", "Solution", "Closer", "Sign-Off"];
    const structureChecks = structureLabels.map((label, i) => {
      const c = Array.isArray(ai?.checks) ? ai.checks[i] : null;
      return {
        label,
        ok: !!c?.ok,
        detail: c?.detail || (ai ? "Not met" : "AI unavailable"),
        score: clamp(typeof c?.score === "number" ? c.score : (c?.ok ? 100 : 0), 0, 100)
      };
    });

    // Weighted structure %
    const sw = Object.assign({ Greeting: 8, Opener: 8, Solution: 67, Closer: 8, "Sign-Off": 9 }, w.sectionWeights || {});
    const swTotal = structureLabels.reduce((a, lab) => a + (sw[lab] || 0), 0) || 100;

    let structurePctWeighted = 0;
    structureLabels.forEach((lab, i) => {
      const c = structureChecks[i];
      const pct = clamp(Number(c?.score ?? 0), 0, 100);
      structurePctWeighted += pct * (sw[lab] || 0) / swTotal;
    });
    structurePctWeighted = clamp(structurePctWeighted, 0, 100);

    const statusCheck   = { label: `Submit As is "${expectedStatus}"`, ok: statusOk,   detail: `Selected: ${attempt.status ?? "—"}` };
    const assigneeCheck = { label: `Assignee is "${expectedAssignee}"`, ok: assigneeOk, detail: `Selected: ${attempt.assignee ?? "—"}` };

    // Scoring buckets
    const sum = Math.max(1, (w.sections||0) + (w.status||0) + (w.assignee||0) + (w.keywords||0));
    const sStructure = structurePctWeighted * (w.sections||0) / sum;
    const sStatus    = (statusOk   ? 100 : 0) * (w.status   ||0) / sum;
    const sAssignee  = (assigneeOk ? 100 : 0) * (w.assignee ||0) / sum;
    const score = sStructure + sStatus + sAssignee;

    return {
      checks: [...structureChecks, statusCheck, assigneeCheck],
      score,
      pass: score >= (w.pass || 0),
      structurePct: structurePctWeighted
    };
  };
})();
</script>

<!-- Theme toggle (unchanged) -->
<script>
(function(){
  const THEME_KEY="sim_theme";
  const btn=document.getElementById("themeBtn");
  function apply(mode){
    const dark = mode === "dark";
    document.body.classList.toggle("dark", dark);
    if (btn){
      btn.textContent = dark ? "Light mode" : "Dark mode";
      btn.setAttribute("aria-pressed", String(dark));
    }
  }
  const saved = localStorage.getItem(THEME_KEY);
  const initial = saved || (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light");
  apply(initial);
  if (btn){
    btn.onclick = () => {
      const next = document.body.classList.contains("dark") ? "light" : "dark";
      localStorage.setItem(THEME_KEY, next);
      apply(next);
    };
  }
})();
</script>

</body>
</html>
<!-- === END index.html === -->
